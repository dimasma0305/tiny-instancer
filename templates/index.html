<!-- dm me (@es3n1n) if you want to make a proper frontend for this thing -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>{{challenge.name}} instancer</title>
  <style>
    body {
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 2rem;
    }
    h1 { margin: 0 0 0.5rem; }
    #status, #time-left { margin: 0.25rem 0; }
    #endpoints[hidden] { display: none; }
    ul { padding-left: 1.1rem; }
    button { padding: 0.5rem 0.8rem; }
    #error { color: #b00020; margin-top: 0.5rem; }
  </style>
</head>
<body>
  <h1>{{challenge.name}} instancer</h1>
  <p id="status">Status: loadingâ€¦</p>
  <p id="time-left"></p>
  <p id="error" role="alert"></p>

  <section id="endpoints" hidden>
    <p>Endpoints:</p>
    <ul id="endpoints-list"></ul>
  </section>

  <button id="submit" disabled>Start instance</button>

  {% if hcaptcha_site_key %}
  <div style="display:none">
    <div id="hcaptcha"
         class="h-captcha"
         data-sitekey="{{ hcaptcha_site_key }}"
         data-size="invisible"
         data-callback="onCaptchaSuccess"
         data-error-callback="onCaptchaError"
         data-expired-callback="onCaptchaExpired"></div>
  </div>
  <script src="https://hcaptcha.com/1/api.js" async defer></script>
  {% endif %}

  <noscript>JavaScript is required.</noscript>

  <script>
    const API = '/v1/instances/{{challenge.name}}';
    const AUTH_URL = '/auth?state={{challenge.name}}';

    const els = {
      status: document.getElementById('status'),
      time: document.getElementById('time-left'),
      endpointsSection: document.getElementById('endpoints'),
      endpointsList: document.getElementById('endpoints-list'),
      button: document.getElementById('submit'),
      error: document.getElementById('error'),
    };

    const captchaEnabled = {% if hcaptcha_site_key %}true{% else %}false{% endif %};
    let pendingMethod = null;

    let lastStatus = 'unknown';
    let updating = false;
    let remaining = 0;
    let total = 0;

    const redirectToAuth = () => {
      window.location.replace(AUTH_URL);
    };

    if (!localStorage.token) {
      redirectToAuth();
    }

    const showError = (msg) => {
      els.error.textContent = msg || '';
    };
    const clearError = () => {
        showError('');
    };

    const renderTime = () => {
      if (lastStatus !== 'stopped') {
        els.time.textContent = `Time left: ${Math.max(0, remaining)} / ${total} seconds`;
      } else {
        els.time.textContent = '';
      }
    };

    const formatEndpoint = (ep) => {
      if (ep.kind === 'http') {
        const port = ep.port && ep.port !== 80 ? `:${ep.port}` : '';
        return `http://${ep.host}${port}`;
      }
      if (ep.kind === 'https') {
        const port = ep.port && ep.port !== 443 ? `:${ep.port}` : '';
        return `https://${ep.host}${port}`;
      }
      return `tcp://${ep.host}:${ep.port}`;
    };

    const renderEndpoints = (endpoints) => {
      els.endpointsList.innerHTML = '';

      endpoints.forEach((ep) => {
        const url = formatEndpoint(ep);
        const a = document.createElement('a');
        a.href = url;
        a.textContent = url;
          if (ep.kind === 'http' || ep.kind === 'https') {
          a.target = '_blank';
          a.rel = 'noopener noreferrer';
        }

        const li = document.createElement('li');
        li.appendChild(a);
        els.endpointsList.appendChild(li);
      });
    };

    const updateStatus = async () => {
      if (updating) {
          return;
      }
      if (!localStorage.token) {
          return redirectToAuth();
      }

      updating = true;
      try {
        const resp = await fetch(API, {
          cache: 'no-store',
          headers: { 'Authorization': `Bearer ${localStorage.token}` }
        });

        if (resp.status === 401) return redirectToAuth();

        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) {
          els.status.textContent = 'Status: error';
          showError(data?.detail || 'Failed to load status.');
          els.button.disabled = true;
          return;
        }

        clearError();

        lastStatus = data.status;
        els.status.textContent = `Status: ${data.status}`;
        els.button.disabled = false;

        if (data.status !== 'stopped') {
          remaining = Number(data.remaining_time ?? 0);
          total = Number(data.timeout ?? 0);
          renderTime();

          els.button.textContent = 'Stop instance';
          renderEndpoints(data.endpoints || []);
          els.endpointsSection.hidden = false;
        } else {
          remaining = 0;
          total = Number(data.timeout ?? 0);
          renderTime();

          els.button.textContent = 'Start instance';
          els.endpointsSection.hidden = true;
          els.endpointsList.innerHTML = '';
        }
      } catch (e) {
        console.error(e);
        els.status.textContent = 'Status: error';
        els.button.disabled = true;

        showError('Network error while loading status.');
      } finally {
        updating = false;
      }
    };

    async function sendAction(method, captchaToken = undefined) {
      if (!localStorage.token) {
          return redirectToAuth();
      }

      try {
        const resp = await fetch(API, {
          method,
          headers: {
            'Authorization': `Bearer ${localStorage.token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(captchaEnabled ? { captcha: captchaToken } : {})
        });

        if (resp.status === 401) return redirectToAuth();

        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) {
          showError(data?.detail || 'Request failed.');
          return;
        }

        clearError();
      } catch (e) {
        console.error(e);
        showError('Network error while sending request.');
      } finally {
        if (captchaEnabled && window.hcaptcha) {
          hcaptcha.reset();
        }

        await updateStatus();
        els.button.disabled = false;
        pendingMethod = null;
      }
    }

    window.onCaptchaSuccess = function(token) {
      if (!pendingMethod) return;
      sendAction(pendingMethod, token);
    };
    window.onCaptchaError = function() {
      els.button.disabled = false;
      showError('Captcha error. Please try again.');
      pendingMethod = null;
    };
    window.onCaptchaExpired = function() {
      els.button.disabled = false;
      showError('Captcha expired. Please try again.');
      pendingMethod = null;
    };

    els.button.addEventListener('click', async () => {
      if (lastStatus === 'unknown') return;
      if (!localStorage.token) return redirectToAuth();

      els.button.disabled = true;
      clearError();

      const method = lastStatus === 'stopped' ? 'PUT' : 'DELETE';

      if (captchaEnabled) {
        pendingMethod = method;
        if (window.hcaptcha && hcaptcha.execute) {
          hcaptcha.execute();
        } else {
          setTimeout(() => window.hcaptcha && hcaptcha.execute && hcaptcha.execute(), 200);
        }
        return;
      }

      sendAction(method);
    });

    updateStatus();
    setInterval(updateStatus, 5000);

    setInterval(() => {
      if (lastStatus !== 'stopped' && remaining > 0) {
        remaining -= 1;
        renderTime();
      }
    }, 1000);
  </script>
</body>
</html>
